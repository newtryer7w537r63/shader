<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Water Shader</title>

<style>
html, body {
    margin: 0;
    padding: 0;
    width: 100%;
    height: 100%;
    overflow: hidden;
    background: #000;
}
canvas {
    display: block;
}
</style>
</head>

<body>

<script src="https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.158.0/examples/js/controls/OrbitControls.js"></script>

<script>
/* ---------- SHADER ---------- */

const WaterShader = {
    uniforms: {
        iGlobalTime: { value: 0 },
        iResolution: { value: new THREE.Vector2() },
        cameraPos: { value: new THREE.Vector3() },
        lightDir: { value: new THREE.Vector3(0.3, 0.5, 1.0).normalize() }
    },

    vertexShader: `
    varying vec3 vWorldPosition;

    void main() {
        vec4 worldPosition = modelMatrix * vec4(position, 1.0);
        vWorldPosition = worldPosition.xyz;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    }
    `,

    fragmentShader: `
    uniform float iGlobalTime;
    uniform vec2 iResolution;
    uniform vec3 cameraPos;
    uniform vec3 lightDir;

    varying vec3 vWorldPosition;

    const float SEA_HEIGHT = 0.8;
    const float SEA_SPEED = 1.0;
    const float SEA_FREQ = 0.2;
    const vec3 SEA_BASE = vec3(0.1,0.2,0.3);

    float noise(vec2 p){
        return sin(p.x)*sin(p.y);
    }

    float map(vec3 p){
        float t = iGlobalTime * SEA_SPEED;
        float h = sin((p.x+p.z)*SEA_FREQ + t) * 0.4;
        return p.y - h;
    }

    vec3 getNormal(vec3 p){
        float e = 0.1;
        return normalize(vec3(
            map(p + vec3(e,0,0)) - map(p),
            e,
            map(p + vec3(0,0,e)) - map(p)
        ));
    }

    void main(){
        vec3 dir = normalize(vWorldPosition - cameraPos);
        vec3 p = vWorldPosition;
        vec3 n = getNormal(p);
        float diff = clamp(dot(n, lightDir), 0.0, 1.0);
        vec3 col = SEA_BASE + diff * vec3(0.2,0.4,0.6);
        gl_FragColor = vec4(col,1.0);
    }
    `
};

/* ---------- THREE SETUP ---------- */

let scene, camera, renderer, controls, uniforms;

init();
animate();

function init() {
    scene = new THREE.Scene();

    camera = new THREE.PerspectiveCamera(
        60,
        window.innerWidth / window.innerHeight,
        0.1,
        5000
    );
    camera.position.set(0, 15, 30);

    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.maxPolarAngle = Math.PI * 0.49;

    const geometry = new THREE.PlaneGeometry(200, 200, 256, 256);

    uniforms = {
        iGlobalTime: { value: 0 },
        iResolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
        cameraPos: { value: camera.position },
        lightDir: { value: new THREE.Vector3(0.3,0.6,1).normalize() }
    };

    const material = new THREE.ShaderMaterial({
        vertexShader: WaterShader.vertexShader,
        fragmentShader: WaterShader.fragmentShader,
        uniforms,
        side: THREE.DoubleSide
    });

    const water = new THREE.Mesh(geometry, material);
    water.rotation.x = -Math.PI / 2;
    scene.add(water);

    window.addEventListener("resize", onResize);
}

function onResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
    uniforms.iResolution.value.set(window.innerWidth, window.innerHeight);
}

function animate() {
    requestAnimationFrame(animate);
    uniforms.iGlobalTime.value += 0.02;
    controls.update();
    renderer.render(scene, camera);
}
</script>

</body>
</html>
